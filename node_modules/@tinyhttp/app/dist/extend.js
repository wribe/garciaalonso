import { Accepts } from '@tinyhttp/accepts';
import { compile } from '@tinyhttp/proxy-addr';
import { checkIfXMLHttpRequest, getFreshOrStale, getQueryParams, getRangeFromHeader, getRequestHeader, reqIs } from '@tinyhttp/req';
import { append, attachment, clearCookie, download, formatResponse, getResponseHeader, json, redirect, send, sendFile, sendStatus, setContentType, setCookie, setHeader, setLinksHeader, setLocationHeader, setVaryHeader, status } from '@tinyhttp/res';
import { getHost, getIP, getIPs, getProtocol, getSubdomains } from './request.js';
import { renderTemplate } from './response.js';
/**
 * Extends Request and Response objects with custom properties and methods
 */
export const extendMiddleware = (app) => ((req, res, next) => {
    const { settings } = app;
    res.get = getResponseHeader(res);
    req.get = getRequestHeader(req);
    if (settings?.bindAppToReqRes) {
        req.app = app;
        res.app = app;
    }
    if (settings?.networkExtensions) {
        let trust = settings?.['trust proxy'] || 0;
        if (trust && typeof trust !== 'function') {
            trust = compile(trust);
            settings['trust proxy'] = trust;
        }
        req.protocol = getProtocol(req, trust);
        req.secure = req.protocol === 'https';
        const host = getHost(req, trust);
        req.hostname = host?.hostname;
        req.port = host?.port;
        req.subdomains = getSubdomains(req, trust, settings.subdomainOffset);
        req.ip = getIP(req, trust);
        req.ips = getIPs(req, trust);
    }
    req.query = getQueryParams(req.url);
    req.is = reqIs(req);
    req.range = getRangeFromHeader(req);
    // Lazily cache Accepts instance to avoid creating multiple Negotiator instances per request
    let acceptsInstance;
    const getAcceptsInstance = () => {
        if (!acceptsInstance)
            acceptsInstance = new Accepts(req);
        return acceptsInstance;
    };
    req.accepts = (...types) => getAcceptsInstance().types(types);
    req.acceptsCharsets = (...charsets) => getAcceptsInstance().charsets(charsets);
    req.acceptsEncodings = (...encodings) => getAcceptsInstance().encodings(encodings);
    req.acceptsLanguages = (...languages) => getAcceptsInstance().languages(languages);
    req.xhr = checkIfXMLHttpRequest(req);
    res.header = res.set = setHeader(res);
    res.send = send(req, res);
    res.json = json(res);
    res.status = status(res);
    res.sendStatus = sendStatus(req, res);
    res.sendFile = sendFile(req, res);
    res.type = setContentType(res);
    res.location = setLocationHeader(req, res);
    res.links = setLinksHeader(res);
    res.vary = setVaryHeader(res);
    res.cookie = setCookie(req, res);
    res.clearCookie = clearCookie(req, res);
    res.render = renderTemplate(req, res, app);
    res.format = formatResponse(req, res, next);
    res.redirect = redirect(req, res, next);
    res.attachment = attachment(res);
    res.download = download(req, res);
    res.append = append(res);
    res.locals ??= {};
    Object.defineProperty(req, 'fresh', { get: () => getFreshOrStale(req, res), configurable: true });
    Object.defineProperty(req, 'stale', { get: () => !getFreshOrStale(req, res), configurable: true });
    next();
});
//# sourceMappingURL=extend.js.map